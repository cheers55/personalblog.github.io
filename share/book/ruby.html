<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>红宝石4 | 🌈 程晓辉</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="Personal Website">
    
    <link rel="preload" href="/assets/css/0.styles.f175d11a.css" as="style"><link rel="preload" href="/assets/js/app.068a4f65.js" as="script"><link rel="preload" href="/assets/js/2.05078575.js" as="script"><link rel="preload" href="/assets/js/23.03bffcec.js" as="script"><link rel="prefetch" href="/assets/js/10.c4fe3017.js"><link rel="prefetch" href="/assets/js/11.65037793.js"><link rel="prefetch" href="/assets/js/12.682fc023.js"><link rel="prefetch" href="/assets/js/13.db347a96.js"><link rel="prefetch" href="/assets/js/14.5a72dead.js"><link rel="prefetch" href="/assets/js/15.002997dd.js"><link rel="prefetch" href="/assets/js/16.66f578cb.js"><link rel="prefetch" href="/assets/js/17.87f74e49.js"><link rel="prefetch" href="/assets/js/18.859d3b68.js"><link rel="prefetch" href="/assets/js/19.decaaf0e.js"><link rel="prefetch" href="/assets/js/20.49797c96.js"><link rel="prefetch" href="/assets/js/21.2189bf11.js"><link rel="prefetch" href="/assets/js/22.7567fad1.js"><link rel="prefetch" href="/assets/js/24.6ecb55a4.js"><link rel="prefetch" href="/assets/js/25.847e675e.js"><link rel="prefetch" href="/assets/js/26.dfc963a1.js"><link rel="prefetch" href="/assets/js/27.e850d9ac.js"><link rel="prefetch" href="/assets/js/28.6d0263fc.js"><link rel="prefetch" href="/assets/js/29.bd467d42.js"><link rel="prefetch" href="/assets/js/3.bbe5046a.js"><link rel="prefetch" href="/assets/js/30.12d0af71.js"><link rel="prefetch" href="/assets/js/31.8182fad1.js"><link rel="prefetch" href="/assets/js/32.6ee19553.js"><link rel="prefetch" href="/assets/js/33.97c6a2a1.js"><link rel="prefetch" href="/assets/js/34.d163b248.js"><link rel="prefetch" href="/assets/js/35.24e0e9b7.js"><link rel="prefetch" href="/assets/js/36.227bccf9.js"><link rel="prefetch" href="/assets/js/37.7e752b83.js"><link rel="prefetch" href="/assets/js/38.63c33a72.js"><link rel="prefetch" href="/assets/js/39.c447da1a.js"><link rel="prefetch" href="/assets/js/4.d2be4349.js"><link rel="prefetch" href="/assets/js/40.fdafddc3.js"><link rel="prefetch" href="/assets/js/41.7b4ac0b7.js"><link rel="prefetch" href="/assets/js/42.8b335077.js"><link rel="prefetch" href="/assets/js/43.004ba8d0.js"><link rel="prefetch" href="/assets/js/44.4ed22e86.js"><link rel="prefetch" href="/assets/js/45.aefec7bf.js"><link rel="prefetch" href="/assets/js/46.41c29fbf.js"><link rel="prefetch" href="/assets/js/47.2c42172b.js"><link rel="prefetch" href="/assets/js/48.d254146c.js"><link rel="prefetch" href="/assets/js/5.e62e8fba.js"><link rel="prefetch" href="/assets/js/6.4a0603f6.js"><link rel="prefetch" href="/assets/js/7.60e05ba3.js"><link rel="prefetch" href="/assets/js/8.f9b46b6e.js"><link rel="prefetch" href="/assets/js/9.0cf5007c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f175d11a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">🌈 程晓辉</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/share/" class="nav-link router-link-active">
  技术集
</a></div><div class="nav-item"><a href="/engineering/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/frame/" class="nav-link">
  框架
</a></div><div class="nav-item"><a href="/panClient/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/aboutMe/" class="nav-link">
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/share/" class="nav-link router-link-active">
  技术集
</a></div><div class="nav-item"><a href="/engineering/" class="nav-link">
  工程化
</a></div><div class="nav-item"><a href="/frame/" class="nav-link">
  框架
</a></div><div class="nav-item"><a href="/panClient/" class="nav-link">
  泛客户端
</a></div><div class="nav-item"><a href="/aboutMe/" class="nav-link">
  关于我
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>红宝石4</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/share/book/ruby.html#_1-什么是-javascript" class="sidebar-link">1. 什么是 JavaScript</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/share/book/ruby.html#_2-html-中的-javascript" class="sidebar-link">2. HTML 中的 JavaScript</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/share/book/ruby.html#_3-语言基础" class="sidebar-link">3. 语言基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/share/book/ruby.html#❤️3-1-1-变量-var" class="sidebar-link">❤️3.1.1 变量 - var</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-1-2-变量-let" class="sidebar-link">3.1.2 变量 - let</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-1-3-变量-const" class="sidebar-link">3.1.3 变量 - const</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-1-4-变量-总结" class="sidebar-link">3.1.4 变量 - 总结</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-1-数据类型" class="sidebar-link">3.2.1 数据类型</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-2-typeof操作符" class="sidebar-link">3.2.2 typeof操作符</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-3-undefined类型" class="sidebar-link">3.2.3 Undefined类型</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-4-null类型" class="sidebar-link">3.2.4 Null类型</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-5-boolean类型" class="sidebar-link">3.2.5 Boolean类型</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-6-number类型" class="sidebar-link">3.2.6 Number类型</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-7-string类型" class="sidebar-link">3.2.7 String类型</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-8-symbol类型" class="sidebar-link">3.2.8 Symbol类型</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-2-9-object-类型" class="sidebar-link">3.2.9 Object 类型</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-3-操作符" class="sidebar-link">3.3 操作符</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-3-1-一元操作符" class="sidebar-link">3.3.1 一元操作符</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-3-2-布尔操作符" class="sidebar-link">3.3.2 布尔操作符</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-4-语句" class="sidebar-link">3.4 语句</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-4-1-while-语句" class="sidebar-link">3.4.1 while 语句</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-4-2-for-in-语句" class="sidebar-link">3.4.2 for-in 语句</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_3-4-3-for-of-语句" class="sidebar-link">3.4.3 for-of 语句</a></li></ul></li><li><a href="/share/book/ruby.html#_4-变量、作用域与内存" class="sidebar-link">4. 变量、作用域与内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_4-1-原始值与引用值" class="sidebar-link">4.1 原始值与引用值</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_4-2-垃圾回收" class="sidebar-link">4.2 垃圾回收</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_4-2-1-标记清除" class="sidebar-link">4.2.1 标记清除</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_4-2-2-引用计数" class="sidebar-link">4.2.2 引用计数</a></li><li class="sidebar-sub-header"><a href="/share/book/ruby.html#_4-2-3-内存管理" class="sidebar-link">4.2.3 内存管理</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="红宝石4"><a href="#红宝石4" class="header-anchor">#</a> 红宝石4</h1> <h2 id="_1-什么是-javascript"><a href="#_1-什么是-javascript" class="header-anchor">#</a> 1. 什么是 JavaScript</h2> <p>完整的 JavaScript 实现包含以下几个部分：</p> <ul><li>核心(ECMAScript262)：由 ECMA-262 定义并提供核心功能；</li> <li>文档对象模型(DOM Document Object Model)：提供与网页内容交互的方法和接口；</li> <li>浏览器对象模型(BOM Bower Object Model)：提供与浏览器交互的方法和接口；</li></ul> <p><img src="/javascript.png" alt=""></p> <h2 id="_2-html-中的-javascript"><a href="#_2-html-中的-javascript" class="header-anchor">#</a> 2. HTML 中的 JavaScript</h2> <p><strong>script</strong> 元素几个重要的属性：</p> <ul><li><code>async</code>：表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载。异步脚本不能保证按照它们在页面中出现的次序执行；</li> <li><code>defer</code>：把脚本推迟到文档渲染完毕后再执行。推迟的脚本原则上按照它们被列出的次序执行；</li></ul> <p>对不推迟执行的脚本，浏览器必须解释完位于 <strong>script</strong> 元素中的代码，然后才能继续渲染页面的剩余部分。为此，通常应该把 <strong>script</strong> 元素放到页面末尾，介于主内容之后及 <code>&lt;/body&gt;</code> 标签 之前。否则会出现以下问题：</p> <blockquote><p>浏览器窗口完全空白，<strong>原因</strong>：必须把所有 <strong>JavaScript</strong> 代码都<strong>下载、解析和解释</strong>完成后，才能开始渲染页面。对于需要很多 <strong>JavaScript</strong> 的页面，这会导致页面渲染的明显延迟。</p></blockquote> <h2 id="_3-语言基础"><a href="#_3-语言基础" class="header-anchor">#</a> 3. 语言基础</h2> <h3 id="❤️3-1-1-变量-var"><a href="#❤️3-1-1-变量-var" class="header-anchor">#</a> ❤️3.1.1 变量 - var</h3> <p>用来定义变量。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var num = 666；
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><blockquote><p>注意点：这个关键字声明的变量会自动提升到函数作用域顶部。俗称”变量提升“。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>// name 会被提升 
console.log(name); // undefined 
var name = 'Matt';
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-1-2-变量-let"><a href="#_3-1-2-变量-let" class="header-anchor">#</a> 3.1.2 变量 - let</h3> <p><code>let</code> 跟 <code>var</code> 的作用差不多，但有着非常重要的区别。最明显的区别是，<code>let</code> 声明的范围是块作用域， 而 <code>var</code> 声明的范围是函数作用域。</p> <p><strong>1. 暂时性死区</strong></p> <p>let 声明的变量不会在作用域中被提升。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// age 不会被提升
console.log(age); // ReferenceError:age 没有定义 
let age = 26;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>2. 全局声明</strong></p> <p>与 <code>var</code> 关键字不同，使用 <code>let</code> 在全局作用域中声明的变量不会成为 <code>window</code> 对象的属性(var 声明的变量则会)。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var name = 'Matt'; 
console.log(window.name); // 'Matt'

let age = 26;
console.log(window.age); // undefined
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_3-1-3-变量-const"><a href="#_3-1-3-变量-const" class="header-anchor">#</a> 3.1.3 变量 - const</h3> <p><code>const</code> 的行为与 <code>let</code> 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 <code>const</code> 声明的变量会导致运行时错误。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const age = 26;
age = 36; // TypeError
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><code>const</code> 声明的限制只适用于它指向的变量的引用。换句话说，如果 <code>const</code> 变量引用的是一个对象，那么修改这个对象内部的属性并不违反 <code>const</code> 的限制。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const person = {};
person.name = 'Matt'; // ok
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_3-1-4-变量-总结"><a href="#_3-1-4-变量-总结" class="header-anchor">#</a> 3.1.4 变量 - 总结</h3> <p><strong>1. 不使用 var</strong></p> <p>只使用 <code>let</code> 和 <code>const</code> 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p> <p><strong>2. const 优先，let 次之</strong></p> <p>使用 <code>const</code> 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。同时也能迅速发现因意外赋值导致的非预期行为。</p> <h3 id="_3-2-1-数据类型"><a href="#_3-2-1-数据类型" class="header-anchor">#</a> 3.2.1 数据类型</h3> <p>简单数据类型（原始值）：<code>Undefined、Null、Boolean、Number、String 和 Symbol</code>。</p> <p>复杂数据类型（引用值）：<code>Object</code>。</p> <h3 id="_3-2-2-typeof操作符"><a href="#_3-2-2-typeof操作符" class="header-anchor">#</a> 3.2.2 typeof操作符</h3> <p>确定任意变量的数据类型。</p> <blockquote><p>注意：typeof null 返回的是&quot;object&quot;。这是因为特殊值 null 被认为是一个对空对象的引用。</p></blockquote> <h3 id="_3-2-3-undefined类型"><a href="#_3-2-3-undefined类型" class="header-anchor">#</a> 3.2.3 Undefined类型</h3> <p>当使用 <code>var</code> 或 <code>let</code> 声明了变量但没有初始化时，就相当于给变量赋予了 <code>undefined</code> 值。</p> <h3 id="_3-2-4-null类型"><a href="#_3-2-4-null类型" class="header-anchor">#</a> 3.2.4 Null类型</h3> <p><code>null</code> 值表示一个空对象指针，这也是给 <code>typeof</code> 传一个 <code>null</code> 会返回&quot;object&quot;的原因。在定义将来要保存对象值的变量时，建议使用 <code>null</code> 来初始化，不要使用其他值。</p> <h3 id="_3-2-5-boolean类型"><a href="#_3-2-5-boolean类型" class="header-anchor">#</a> 3.2.5 Boolean类型</h3> <p><code>true</code> 和 <code>false</code>。</p> <blockquote><p>注意：不同类型与布尔值之间存在隐式转换。非空字符串、非0、任意对象会被转换为 true。空（''）、零（0、NaN）、空对象（null）、undefined会被转换为 false。</p></blockquote> <h3 id="_3-2-6-number类型"><a href="#_3-2-6-number类型" class="header-anchor">#</a> 3.2.6 Number类型</h3> <p><code>Number</code> 类型使用 <code>IEEE 754</code> 格式表示整数和浮点值(在某些语言中也叫双精度值)。</p> <p><strong>1. 数值转换 - Number()函数</strong></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>Number(true) = 1; Number(false) = 0; // 布尔值
Number(123) = 123 // 数值;
Number(null) = 0 // null;
Number(undefined) = NaN // undefined类型;
Number(&quot;123&quot;) = 123; Number(&quot;0123&quot;) = 123; Number(&quot;1.1&quot;) = 1.1; Number(&quot; &quot;) = 0; Number(&quot;Hello&quot;) = NaN; // 字符串
对象：调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p><strong>2. 数值转换 - parseInt()函数</strong></p> <p>通常在需要得到整数时可以优先使用。也接收第二个参数，用于指定底数(进制数)。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>parseInt(&quot;123cheers&quot;) = 123;
parseInt(&quot;&quot;) = NaN;
parseInt(22.5) = 22;
parseInt(&quot;10&quot;, 10) = 10; // 按十进制解析
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>3. 数值转换 - parseFloat()函数</strong></p> <p>解析到一个无效的浮点数值字符为止。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>parseInt(&quot;123cheers&quot;) = 123;
parseInt(&quot;&quot;) = NaN;
parseInt(22.5) = 22.5;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="_3-2-7-string类型"><a href="#_3-2-7-string类型" class="header-anchor">#</a> 3.2.7 String类型</h3> <p><strong>1. 模板字面量</strong></p> <p>常用特性是支持字符串插值</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let pageHTML = ` 
&lt;div&gt; 
    &lt;a href=&quot;#&quot;&gt; 
        &lt;span&gt;Jake&lt;/span&gt; 
    &lt;/a&gt; 
&lt;/div&gt;`;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>其中变量用 <code>${}</code> 来表示</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let num = 666;
const str = `你的幸运数字是${num}` // 你的幸运数字是666
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="_3-2-8-symbol类型"><a href="#_3-2-8-symbol类型" class="header-anchor">#</a> 3.2.8 Symbol类型</h3> <p><code>Symbol</code> 是原始值，且实例是唯一、不可变的。用途是确保对象属性使用<strong>唯一标识符</strong>，不会发生属性冲突的危险。</p> <p><strong>1. 基本用法</strong></p> <p>使用 <code>Symbol()</code> 函数初始化，调用时，也可以传入一个字符串参数作为对符号的描述，将来可以通过这个字符串来调试代码。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let easySymbol = Symbol('cxh');
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>因为是唯一，所以两个看起来相同的 <code>Symbol</code> 却不相同。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let easySymbol1 = Symbol('cxh');
let easySymbol2 = Symbol('cxh');

console.log(easySymbol1 == easySymbol2); // false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果想让它们相同，可以使用 <code>Symbol.for()</code> 方法。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let easySymbol1 = Symbol.for('cxh');
let easySymbol2 = Symbol.for('cxh');

console.log(easySymbol1 == easySymbol2); // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><blockquote><p>注意：Symbol()函数不能与 new 关键字一起作为构造函数使用。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li><code>Object.getOwnPropertyNames()</code> 返回对象实例的常规属性数组。</li> <li><code>Object.getOwnPropertySymbols()</code> 返回对象实例的 <strong>符号</strong> 属性数组。</li> <li><code>Reflect.ownKeys()</code> 会返回两种类型的键。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>let s1 = Symbol('foo'); 

let o = { 
 [s1]: 'foo val', 
 baz: 'baz val'
}; 

console.log(Object.getOwnPropertySymbols(o));  // [Symbol(foo)] 

console.log(Object.getOwnPropertyNames(o));  // [&quot;baz&quot;] 

console.log(Reflect.ownKeys(o));  // [&quot;baz&quot;, Symbol(foo)]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p><strong>2. Symbol.iterator</strong></p> <p>该方法返回对象默认的迭代器。由 <code>for-of</code> 语句使用。换句话说，这个符号表示实现迭代器 API 的函数。 <code>Symbol.iterator</code> 函数生成的对象应该通过其 <code>next()</code> 方法陆续返回值。</p> <h3 id="_3-2-9-object-类型"><a href="#_3-2-9-object-类型" class="header-anchor">#</a> 3.2.9 Object 类型</h3> <p>每个 <code>Object</code> 实例都有如下属性和方法。</p> <ul><li>constructor：用于创建当前对象的函数。</li> <li>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。</li></ul> <h3 id="_3-3-操作符"><a href="#_3-3-操作符" class="header-anchor">#</a> 3.3 操作符</h3> <h3 id="_3-3-1-一元操作符"><a href="#_3-3-1-一元操作符" class="header-anchor">#</a> 3.3.1 一元操作符</h3> <p>前缀递增/递减操作符，变量的值都会在语句被<strong>求值之前</strong>改变。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let age = 29;
let nextage = --age + 1;

console.log(age); // 28 
console.log(nextage); // 30
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>后缀递增/递减操作符，变量的值都会在语句被<strong>求值后</strong>才发生。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>let age = 29;
let nextage = age-- + 1;

console.log(age); // 29 
console.log(nextage); // 30
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_3-3-2-布尔操作符"><a href="#_3-3-2-布尔操作符" class="header-anchor">#</a> 3.3.2 布尔操作符</h3> <p><code>!!</code> 相当于调用了转型函数 <code>Boolean()</code>。第一个叹号总会返回布尔值。第二个叹号对该布尔值取反。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>console.log(!!&quot;blue&quot;); // true 
console.log(!!0); // false 
console.log(!!NaN); // false 
console.log(!!&quot;&quot;); // false 
console.log(!!12345); // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="_3-4-语句"><a href="#_3-4-语句" class="header-anchor">#</a> 3.4 语句</h3> <h3 id="_3-4-1-while-语句"><a href="#_3-4-1-while-语句" class="header-anchor">#</a> 3.4.1 while 语句</h3> <p>先检测退出条件，再执行循环体内的代码。while 循环体内的代码有可能不会执行。</p> <h3 id="_3-4-2-for-in-语句"><a href="#_3-4-2-for-in-语句" class="header-anchor">#</a> 3.4.2 for-in 语句</h3> <p>用于枚举对象中的非符号键属性。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const person = {
    name: 'cxh',
    age: 18
};

for(let key in person){
    console.log(key); // name age
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_3-4-3-for-of-语句"><a href="#_3-4-3-for-of-语句" class="header-anchor">#</a> 3.4.3 for-of 语句</h3> <p>用于遍历可迭代对象的元素。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>const person = [
    {name: 'cxh', age: 18},
    {name: 'zq', age: 28}
];

for(let item of person){
    console.log(item); // {name: &quot;cxh&quot;, age: 18} {name: &quot;zq&quot;, age: 28}
};
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="_4-变量、作用域与内存"><a href="#_4-变量、作用域与内存" class="header-anchor">#</a> 4. 变量、作用域与内存</h2> <h3 id="_4-1-原始值与引用值"><a href="#_4-1-原始值与引用值" class="header-anchor">#</a> 4.1 原始值与引用值</h3> <p><strong>原始值</strong>就是最简单的数据，<strong>引用值</strong>则是由多个值构成的对象。保存<strong>原始值</strong>的变量是<strong>按值</strong>访问的。保存<strong>引用值</strong>的变量是按<strong>引用</strong>访问的。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 原始值
let num1 = 5;
let num2 = num1;

num1 = 30;

console.log(num1); // 30
console.log(num2); // 5
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="/data_val.png" alt=""></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>// 引用值
const person1 = {
    name: 'cxh'
};

const person2 = person1;
person1.name = 'zq';

console.log(person1); // zq
console.log(person2); // zq
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p><img src="/data_obj.png" alt=""></p> <h3 id="_4-2-垃圾回收"><a href="#_4-2-垃圾回收" class="header-anchor">#</a> 4.2 垃圾回收</h3> <h3 id="_4-2-1-标记清除"><a href="#_4-2-1-标记清除" class="header-anchor">#</a> 4.2.1 标记清除</h3> <p>最常用的垃圾回收策略是 <strong>标记清理</strong>。</p> <p>垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p> <h3 id="_4-2-2-引用计数"><a href="#_4-2-2-引用计数" class="header-anchor">#</a> 4.2.2 引用计数</h3> <p>对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。</p> <blockquote><p>严重的问题：循环引用。对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。</p></blockquote> <div class="language- line-numbers-mode"><pre class="language-text"><code>function problem() { 
    let objectA = new Object(); 
    let objectB = new Object(); 

    objectA.someOtherObject = objectB; 
    objectB.anotherObject = objectA; 
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="_4-2-3-内存管理"><a href="#_4-2-3-内存管理" class="header-anchor">#</a> 4.2.3 内存管理</h3> <p><strong>1. 通过 const 和 let 声明提升性能</strong></p> <p><strong>const 和 let</strong> 都以块为作用域，所以对比 <strong>var</strong>，会更早地让垃圾回收程序介入，今早回收应该回收的内存。</p> <p><strong>2. 隐藏类和删除操作</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.068a4f65.js" defer></script><script src="/assets/js/2.05078575.js" defer></script><script src="/assets/js/23.03bffcec.js" defer></script>
  </body>
</html>
